title: JVM内存模型
author: Loux
cover: /img/post/16.jpg
tags:
  - JVM
categories:
  - JVM
date: 2019-09-23 19:24:00
---
当我们初学Java的时候，编写好.java的文件后总是会先用javac命令编译为class文件，再使用java命令使class文件在java虚拟机(Java Virtual Machine)上一句一句解释执行。而因为java内存采用自动管理机制—即：  
1. 当程序准备运行时，由JVM向操作系统请求一定的内存空间，我们称之为初始内存空间，程序运行中使用到的内存都由JVM划分
2. 程序运行的过程中，java程序不断的向JVM请求内存空间，当初始内存空间不够时，JVM会继续向操作系统申请更多的内存以供java程序使用
3. 当程序继续运行并向JVM申请内存空间，而这时JVM已经申请的内存达到了其所规定的最大值，程序将会抛出内存溢出异常，即我们常见的OutOfMemoryError  

而Java语言使用这种内存管理机制优点也是很明显的，我们编写的程序不需要和各种操作系统打交道(windows、linux等)，只需要和JVM打交道就行了；而我们开发者也只需了解JVM是如何分配内存的，不用关心各种操作系统是如何管理内存的，使得我们的学习成本大大降低了。  
顺便吐槽一句，由于java语言执行的方式，在以前很多人嘲笑其执行效率低下。但是随着这些年来JVM的不断优化与CPU性能的几何倍增长，Java语言与C/C++系的语言执行效率正在不断缩小。
## 为什么要了解JVM
虽然在日常工作中，Java程序员不需要去编写释放内存的代码(内存自动管理机制，GC的存在)，学习编程越来越轻松。但这也就导致了许多人对JVM知之甚少，一旦程序出现内存泄漏、OutOfMemoryError、StackOverFlowError等问题时，往往束手无策，很难排查出问题所在。所以说要想成为一名优秀的Java程序员，JVM相关的知识一定不能落下。熟悉JVM对我们有以下好处：
* 能更加深刻的理解Java程序运行的原理
* 能够在JVM层面对Java程序进行优化，使其性能更好
* 当程序出现内存溢出、栈溢出等问题，能够快速的排查问题
* 面试官常常会问到JVM内存模型等问题，要想升职加薪，走上人生巅峰，掌握JVM相关的知识是必不可少的  

## JVM运行时数据区
根据《Java虚拟机规范》(Java SE 7版)规定，Java虚拟机所管理的内存，将会分为以下几个运行时的数据区域：堆(Heap)、本地方法栈(Native Method Stack)、虚拟机栈(VM Stack)、方法区(Method Area)、程序计数器(Programe Counter Register)。其结构如下图所示:

![JVM内存模型](/images/pasted-21.png)
从图中我们可以看到方法区、堆空间是线程共享的；而栈、程序计数器是线程隔离的，即随着线程执行结束而消亡。
而关于线程共享等知识，我已在[《Volatile关键字与Atomic类》](https://www.lxfun.cn/2019/07/27/synchronized%E3%80%81volatile%E4%B8%8EAtomic%E7%B1%BB/)一文章中详细描述了。下面我们具体看一下图中的每一个内存区域到底作用是什么
### 程序计数器
程序计数器(Programe Counter Register)是一块比较小的内存空间，它保存着线程需要执行指令的地址。我们知道在多线程中，线程只有获得了cpu执行权才能执行其代码，当执行中途cpu执行权可能会被其它cpu所抢夺，当下一次该线程又获得cpu执行权时正是由于程序计数器的存在，让线程知道应该执行哪一行代码。各线程之间程序计数器独立存储、互不影响，即该区域为线程私有。  

在JVM规范中规定，如果线程执行的是非native方法，则程序计数器中保存的是当前需要执行的指令的地址；如果线程执行的是native方法，则程序计数器中的值是undefined。由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，因此，此内存区域是唯一一个在JVM规范中没有规定任何OutOfMemoryError情况的区域。
### 虚拟机栈
说到栈，大家都会想到数据结构所学的栈这种先进后出的数据结构，进行出栈与入栈的一端被称为栈顶，而入栈操作又被称为压栈。虚拟机栈是Java方法执行的内存模型，它之中存储了许多的栈帧，而每一个栈帧都对应着一个被调用的方法，在栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、指向当前方法所属的类的运行时常量池的引用(Reference to runtime constant pool)、方法返回地址(Return Address)和一些额外的附加信息。下图表示了栈的模型结构：

![虚拟机栈结构](/images/pasted-22.png)
（1）局部变量表：就是用来存储方法中的局部变量（包括在方法中声明的非静态变量以及函数形参）。对于基本数据类型的变量，直接存储它的值，对于引用类型的变量，则存的是指向对象的引用。局部变量表的大小在编译器就可以确定其大小了，因此在程序执行期间局部变量表的大小是不会改变的。  

（2）操作数栈：方法执行的过程，其实就是不断计算并求值的过程，而操作数栈则是记录了方法执行过程中所要进行的操作，例如加、减、取模、求余等等。  

（3）指向运行时常量池的引用：在方法执行过程中，也许会使用到类中定义的常量，所以存在该引用方便获取常量的值。  

（4）方法返回地址：当一个方法执行完毕之后，要返回到之前调用该方法的地方，因此在栈帧中必须保存一个方法返回地址。由于每个线程正在执行的方法可能不同，因此每个线程都会有一个自己的Java栈，互不干扰。也就解释了栈是线程私有的。  

当线程执行一个方法时，会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。因此可知，线程当前执行的方法所对应的栈帧必定位于Java栈的顶部。在这个区域规定了两种异常状况：
* 如果线程请求的栈深入大于虚拟机所允许的深度，将抛出StackOverFlowError异常。例如在编写递归方法时未明确退出递归的条件，导致方法一直调用，出现StackOverFlowError
* 当Java虚拟机扩展到无法申请内存到足够的内存，就会抛出OutOfMemoryError异常。  

### 本地方法栈
本地方法栈和虚拟机栈所发挥的作用是很相似的，它们之间的区别不过是 虚拟机栈为虚拟机执行的Java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务。本地方法栈也可能会抛出虚拟机栈的两种异常。  

### 堆空间
堆是JVM内存管理的最大的一块区域，此内存区域的唯一目的就是存放对象的实例，所有对象实例与数组都要在堆上分配内存。它也是GC主要“照顾”的区域。堆空间是线程共享的区域，如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将抛出OutOfMemoryError异常。为了更好的支持GC,堆空间被分为了以下几个区域：
（1）年轻代：常常又被划分为Eden区和Survivor区(Eden空间、From Survivor空间、To Survivor空间；空间分配比例是8：1：1）,新创建的对象总是创建在Eden Space。
（2）老年代：当年轻代的对象经过一次或多次GC中存活下来，将会转移到老年代。默认JVM新生代与老生代所占内存的比例默认为1:2。
（3)永久代：JDK8中已删除，取而代之的则是元数据区。
### 方法区
方法区存储着每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等，它也是线程共享的区域。方法区是堆的一个逻辑部分，为了区分Java堆，它还有一个别名Non-Heap（非堆）。相对而言，GC对于这个区域的收集是很少出现的。当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。而之前我们提到的被删除的“永久代”则是HotSpot 虚拟机在 JDK7 及以前的版本对方法区的具体实现，但注意，其它虚拟机并没有永久代，这是 HotSpot 虚拟机特有的。  

<b>运行时常量池</b>也是方法区中的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外,还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入运行时常量池中存放。运行时常量池相对于class文件常量池的另外一个特性是具备动态性，java语言并不要求常量一定只有编译器才产生，也就是并非预置入class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中。

<b>直接内存</b>并不是虚拟机运行时数据区的一部分，也不是JVM规范中定义的内存区域。但这部分内存也被频繁的使用，而且也可能导致OutOfMemoryError异常出现。JDK1.4中新引入了NIO机制，它是一种基于通道与缓冲区的新I/O方式，可以直接从操作系统中分配直接内存，即直接堆外分配内存，这样能在一些场景中提高性能，因为避免了在Java堆和Native堆中来回复制数据。
## JDK8中的元空间
元空间其实也是对方法区的一种具体实现，不过它与永久代最大的区别则是<b>元空间不在堆中了，也不在JVM中了，而是在本地内存中。</b>把它从堆中分离出来的原因主要有以下几点：  
（1）移除永久代是为融合HotSpot JVM与 JRockit VM而做出的努力，因为JRockit没有永久代，不需要配置永久代。  
（2）永久代会位GC带来不必要的复杂度，而且回收效率偏低。  
（3）类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。
（4）字符串常量存储在永久代中比较容易内存溢出。  

下面给出JDK8中JVM内存模型结构图：

![JDK8中的JVM内存模型](/images/pasted-23.png)
其中依然白色区域为线程共享，绿色区域为线程隔离。  

--- 

<b>本文中图示为网上寻找的图片，同时也结合了不少JVM相关的博客，若本篇文章中存在错误，请指正！谢谢</b>