title: JVM类加载器
author: Loux
cover: /img/post/18.jpg
tags:

  - JVM
categories:
  - JVM
date: 2019-10-14 14:51:00  

---

上篇文章对JVM类加载的机制做了介绍，除开使用和卸载外，类加载主要分为加载、验证、准备、解析、初始化五个阶段，其中验证、准备、解析又统称为链接阶段。但是在加载阶段中，要想把类加载进JVM内存，就要使用类加载器。

## 类加载器介绍

JVM开发规范中对于加载过程的描述为“通过一个类的全限定名来获取此类的二进制字节流”，而这个操作如果固定只能在虚拟机中实现，那么程序将不能自定义加载类，对于灵活性来说，被限制了。所以HotSpot设计团队(JDK 8以上自带的虚拟机)也允许这个操作在虚拟机外部来实现，这样程序员们就可以自定义获取需要的类，而实现这个操作的代码模块我们就叫做“类加载器”。  

百科上对Java类加载器的定义为：

>  **Java类加载器**（英语：Java Classloader）是Java运行时环境（Java Runtime Environment）的一部分，负责动态加载Java类到[Java虚拟机](https://baike.baidu.com/item/Java虚拟机)的内存空间中。类通常是按需加载，即第一次使用该类时才加载。由于有了类加载器，Java运行时系统不需要知道文件与文件系统。学习类加载器时，掌握Java的委派概念很重要。 

对于任意一个类，确定它的唯一性都需要由**加载该类的类加载器与该类本身**一起确定，这是因为每个类加载器都有一个独立的类命名空间。  

总结来说，比较两个类是否相等的前提是由同一个类加载器加载，否则即便这两个类源于同一个class文件，它们两也不相等。

![两个类加载器加载同一个类](/images/JVM01.png)

## 类加载器分类

类加载器大概可分为四类：

* Bootstrap ClassLoader：启动类加载器
* Extension ClassLoader：扩展类加载器
* Application ClassLoader：应用程序类加载器
* User ClassLoader：自定义类加载器

从虚拟机的角度分析，类加载器分为两类：一种是启动类加载器，这个加载器采用了C++语言来实现，是虚拟机自身的一部分；另一种是其它类加载器，这些加载器采用Java语言来实现，独立于虚拟机之外，都继承于抽象类java.lang.ClassLoader。

### 启动类加载器

主要负责加载存放在${JAVA_HOME}/jre/lib/rt.jar(Java基础类库，包括我们熟知的java包与javax包)里面所有的class文件，或者被-Xbootclasspath参数所指定路径中以rt.jar命名的文件。  

### 扩展类加载器

 用来在${JAVA_HOME}/jre/lib/ext,或java.ext.dirs中指明的目录中加载 Java的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。该类由sun.misc.Launcher$ExtClassLoader实现。 

### 应用程序类加载器

 根据 Java应用程序的类路径（java.class.path或CLASSPATH环境变量）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。该类由sun.misc.Launcher$AppClassLoader实现。 

### 自定义类加载器

用户自己编写的类加载器，继承于抽象类CLassLoader，可以根据自己的需要对其进行设计和实现，例如要读取指定路径下的class文件等。  

我们在安装JDK时配置Classpath环境变量就是为了搜索类的路径，这样编译生成的class文件才能被类加载器找到。

## 双亲委派机制

从JDK1.2版本开始，类加载过程中采用了双亲委派模型（父亲委派机制），这种机制能更好的保证Java平台的安全，在此委托机制中，除了Java虚拟机自带的根类加载(根加载器最顶级，无父加载器)以外，其余的类加载器都有且只有一个父加载器。双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有父类加载器反馈自己无法完成这个加载请求（它搜索的范围中没有找打所需的类）时，子加载器才会尝试自己去加载。如下图所示：

![双亲委派模式加载类](/images/JVM02.png)

因此Java程序中，每个类能且只能被加载一次。双亲委派模型还有一个优点是能提供软件系统的安全性，在这个机制下，用户自定义的类加载器不可能加载应该由父类加载器加载的可靠类，从而防止不可靠甚至是恶意的代码代替父类加载器加载可靠代码。如 java.land.Object 类总是由启动类加载器进行加载，其他任何用户自定义的类加载器都不可能加载含有恶意代码的java.land.Object 类。

---

