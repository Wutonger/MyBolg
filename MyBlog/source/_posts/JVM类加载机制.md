title: JVM类加载机制
author: Loux
cover: /img/post/17.jpg
tags:
  - JVM
categories:
  - JVM
date: 2019-10-09 13:48:00
---
上篇文章我们说到了JVM所管理的内存在运行时将会分成程序计数器、堆、本地方法栈、虚拟机栈、方法区五个数据区域，我们知道了Java程序在运行时的各种数据在哪个数据区中运行，同时对内存泄漏、内存溢出等问题有了一定程度的认识，但是我们还不知道经过编译所生成的.class文件是如何被加载到JVM之中的。
## Java程序执行流程
首先来回顾一下Java程序的执行过程中，JVM扮演了一个怎么样的作用：

![Java程序执行过程](/images/pasted-24.png)
假如现在我编写了一个java文件名为Test.java,由图中内容我们可以知道：
1. 首先Test.java文件经过javac命令编译后生成Test.class字节码文件。
2. JVM在指定位置读取Test.class文件解析为二进制字节流加载进运行时数据区域。
3. 最后JVM生成的符合本地机器的指令，例如windows、linux、Mac os等,这也就是为什么Java语言能打出“Write Once，Run Anywhere”这个响当当的口号。

## JVM类加载过程
JVM的基本结构可以分为：类加载器、执行引擎、运行时数据区、本地接口  
<b>Class FIle —> ClassLoader —> 运行时数据区---->执行引擎</b>，如果程序中使用了native方法，则还需要<b>调用本地库接口—>本地方法库</b>。今天我们关注的重点就是ClassLoader的过程。那么类加载过程到底是什么呢？这里给出某位大佬给出的定义：
> JVM把编译好的class文件加载进内存，并对数据进行校验、转换解析和初始化，最终形成JVM可以直接使用的Java类型的过程就是类加载过程。  

类从被加载到虚拟机内存中开始，到卸载出内存为止，它的生命周期包括了七个阶段：

![类加载过程](/images/pasted-25.png)

其中验证、准备、解析这三个阶段又统称为链接阶段。  
### 加载阶段
加载阶段是JVM类加载的第一个阶段，在加载的阶段虚拟机主要完成以下任务：
1. 通过“类全名”来获取定义此类的二进制字节流。
2. 将字节流所代表的静态存储结构转换为方法区的运行时数据结构。
3. 在java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口，所以我们能够通过反射获取类的相关信息。  

但是仔细阅读以上三句话，其实我们可以发现，它只规定了通过“类全名”来获取定义此类的二进制字节流，而并没有规定二进制字节流要来源于本地class文件，准确来说是根本没有说从哪里获取和通过怎样的方式获取。其实目前除了从本地.class文件来获取外，还有以下几种获取类二进制字节流的方式：
* 从Zip包中读取，这很常见，最终成为日后JAR、EAR、WAR格式的基础。
* 从网络获取（URLClassLoader），下载.class文件
* 运行时生成，比如动态代理技术，在java.lang.reflect.Proxy中，就是用ProxyGenerator.generateProxyClass来为特定接口生成代理类的二进制字节流。
* 从数据库中读取.class文件，这种情况一般比较少见  

由于此原因，加载阶段也是整个类加载过程中我们程序员可控性最强的一个阶段，我们可以选择使用系统提供的类加载器，也可以使用自定义的类加载器来完成；我们还可以定义类的来源，本地的class文件、网络下载的文件、Zip包中读取等都可以。值得注意的是，类加载过程的七个阶段并不是一个阶段执行完成后才进行下一个阶段，有可能是交叉进行的，例如在加载阶段未完成的时候一部分字节码文件格式验证可能已经开始。但是验证阶段的开始时间始终在加载阶段的开始时间之后，也就是说它们始终有固定的顺序。  

### 验证阶段
验证阶段就是为了确保class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全。主要包括四个检验过程：文件格式验证、元数据验证、字节码验证与符号引用验证。  

### 准备阶段
准备阶段是正式为类变量分配内存并设置<b>类变量</b>初始值的阶段。请注意类变量即是static类型的变量，实例变量会在对象初始化时随着对象一起分配在堆空间中。下面举一个例子：
> public static int count = 888;  

在JVM中，首先为该类变量在方法区中开辟一块大小为4个字节的内存，并赋予count的值为0，很多人会奇怪，为什么不是888呢？因为这时候尚未开始执行任何Java方法，而把count赋值为888的put static指令是程序被编译后，存放于类构造器()方法之中，所以把count赋值为888的动作将在初始化阶段才会被执行。在准备阶段只会给类变量赋一个初始的值。例如int类型为0，boolean类型为false，float类型为0.0f等。  
对于一些特殊的情况，如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量value就会被初始化为ConstantValue属性所指定的值，假设上面类变量value定义为：  
> public static final int count = 888;

编译时javac将会为count生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将count设置为888。  
<b>总结：如果一个被static 修饰的变量加了final,则在准备阶段就会赋值为设置的值了，否则只是设置为该类型的默认初始值。</b>  
### 解析阶段
解析阶段是虚拟机常量池内的符号引用替换为直接引用的过程。那么什么是符号引用，什么是直接引用呢？  

* 符号引用：符号引用是一组符号来描述所引用的目标对象，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标对象并不一定已经加载到内存中。Java虚拟机明确在Class文件格式中定义的符号引用的字面量形式。
* 直接引用：直接引用可以是直接指向目标对象的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机内存布局实现相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同，如果有了直接引用，那引用的目标必定已经在内存中存在。  

符号引用的概念相对不好理解，举个例子，现在有个Student类的目标对象，我用%##%来表示这个对象，同时其它Student类的对象或其它类的对象均不能使用%##%来描述，也就是说这个对象有没有被加载到内存中都无所谓，我只要能够准确的表示它并唯一即可。  
### 初始化阶段
类初始阶段是类加载过程的最后一步，在上面提到的类加载过程中，除了加载阶段用户应用程序可以通过自定义类加载器参与之外，其余的动作全部由虚拟机主导和控制。初始化阶段是真正开始执行类中定义的Java程序代码（或者说是字节码）。在准备阶段，静态变量已经赋值过一次系统要求的默认初始值，而在初始化阶段则是执行类构造器<clinit>()方法的过程。  
  
<b>类构造器 和 构造方法有什么关系？</b>类构造器：构造class对象，类对象；构造方法：实例化对象！先要执行类构造器才能执行构造方法！也就是说先要有这个类，才能对类进行实例化。在类构造器中构造器中先执行static变量，在执行static{}块，有多个static变量的话按照代码顺序执行。  

在初始化阶段，虚拟机规范则是严格规定有且只有5种情况必须立即对类进行“初始化”（而加载、验证、准备、解析要在此之前执行），5种情况分别是：
* 遇到new、getstatic、putstatic或invokestatic这4条字节码指令时。如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象、读取或设置一个类的静态字段(被final修饰、已在编译器把结果放入常量池的静态字段除外)的时候，以及调用类的静态方法的时候。
* 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
* 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
* 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个类。
* 当使用JDK1.7的动态语言支持时，如果一个java.invoke.MethodHandle 实例最后解析结果REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄。并且这个方法句柄所对应的类没有初始化，则需要先触发其初始化。

## 例题
一段java代码如下:  
```java
class StaticLoad {
	private static StaticLoad staticLoad = new StaticLoad();

	public static int count1;
	public static int count2 = 0;

	private StaticLoad() {
		count1++;
		count2++;
	}

	public static StaticLoad getStaticLoadInstance(){
		return staticLoad;
	}
}

public class TestStaticLoadDemo {

    public static void main(String[] args) {
		   StaticLoad staticLoad = StaticLoad.getStaticLoadInstance();

        System.out.println("count1 = " + staticLoad.count1);
        System.out.println("count2 = " + staticLoad.count2);                         

	}
}
```
相信很多人的答案是1 和 1
其实正确的答案是1 和 0  

--- 
注：本文参考了网上许多讲解JVM类加载的博客